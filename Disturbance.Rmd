---
title: "Human disturbance for species distribution"
output:
  pdf_document: default
  html_document: default
---

Setting up initial state: environmental covariates.
```{r setup, message=FALSE, warning=FALSE}
library(mvtnorm)
library(sp)
library(lattice)
library(spatstat)
library(data.table)
library(raster)
library(rasterVis)
library(ROCR)
library(gridExtra)
library(grid)
library(latticeExtra)
library(NLMR)

source("Share Functions.R")

XY = expand.grid(seq(0, 100, 1), seq(0, 100, 1))
X = XY[,1]
Y = XY[,2]

quad = expand.grid(seq(0, 100, 1), seq(0, 100, 1))
names(quad) = c("X", "Y")

win   = owin(xrange = c(-0.5, 100.5), yrange = c(-0.5, 100.5))


# Setting up covariates
# generate environmental covariate using NLMR
set.seed(2)
v1 <- nlm_fbm(ncol = 101, nrow = 101, fract_dim = 0.9, user_seed = 1)

v2 <- nlm_gaussianfield(ncol = 101, nrow = 101,
                        autocorr_range = 10,
                        mag_var = 80,
                        nug = 1, user_seed = 1)
v3 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 0.2)

v4 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 0.2)

# Display the plot of the covariates
Lv1 = levelplot(v1, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE) 
Lv2 = levelplot(v2, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv3 = levelplot(v3, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv4 = levelplot(v4, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
comb_levObj <- c(Lv1, Lv2, Lv3, Lv4, layout = c(2, 2), merge.legends = T)
update(comb_levObj, main="Environmental covariates")

## Create road network for observer bias
set.seed(4)
network1 = addnetwork(0, 25, angle = 50, p_split = 0.01,
                      split_decay = 0.01, nmult = 0.6,
                      min_angle = 60, sdmult = 1.5, max_levels = 3,
                      xlim = c(0, 100), ylim = c(0, 100))
set.seed(13)
network2 = addnetwork(0, 25, angle = 50, p_split = 0.01, 
                      split_decay = 0.01, nmult = 0.6,
                      min_angle = 60, sdmult = 1.5, max_levels = 3,
                      xlim = c(0, 100), ylim = c(0, 100))

combined = c(network1, network2)
combinednew = fixnodes(combined)
plotroadlist(combinednew, main = "Simulated Road Network", asp = 1)

combinednewnodes = nodelist(combinednew)
summary(combinednewnodes)

PO.data = ppp(x = c(quad$X, combinednewnodes$X),
              y = c(quad$Y, combinednewnodes$Y),
              marks = c(rep("Quad", dim(quad)[1]), rep("Road", dim(combinednewnodes)[1])),
              window = owin(c(0, 100), c(0, 100)))
nndists = nndist(PO.data, k = 1, by = as.factor(marks(PO.data)))

# distance to the nearest road
d_rd = nndists[1:dim(quad)[1], 2] 
levelplot(d_rd ~ quad[,1] + quad[,2],
          main = "d_rd: bias road", asp = "iso")


# from raster to dataframe for the landscape variables
Datav1 = as.data.frame(flip(v1,2))
Datav2 = as.data.frame(flip(v2,2))
Datav3 = as.data.frame(flip(v3,2))
Datav4 = as.data.frame(flip(v4,2))                 

vmat = as.matrix(data.frame(1, Datav1, Datav2, Datav3, Datav4, d_rd))
colnames(vmat)=c("int", "v1", "v2", "v3", "v4", "d_rd")
vmat.df= as.data.frame(vmat)
# Matrice without covariates for bias and the dummy cov
env.mat = vmat[,1:5]
```

# PO Data
We first consider PO data, where the covariates are the same as we used in the French connection markdown document.
```{r, warning=FALSE}
######   WITH PO DATA

# Generate true PPM coefficients based on linear and quadratic terms 
# of 2 covariates
sp1_coef = c(-1.5, 0.6, 2, 1, -0.8)
sp1_int = exp(env.mat %*% sp1_coef)
levelplot(sp1_int ~ quad$X + quad$Y, asp = "iso",
          main = "True intensity")

sp1_int_im = as.im(data.frame(x = quad$X, y = quad$Y,
                              z = sp1_int))

# Generate poitns from the true intensity
sp1_sim = rpoispp(sp1_int_im)
sp1_sim


# environmental info at quad points and species locations
quads = data.frame(X = quad$X, Y = quad$Y, V1 = vmat.df$v1,
                   V2 = vmat.df$v2, V3= vmat.df$v3, 
                   V4 = vmat.df$v4, d_rd = vmat.df$d_rd)

sp_xy = data.frame(X = sp1_sim$x, Y = sp1_sim$y)

sp_env = newenv.var(sp.xy = sp_xy, env.grid = quads, env.scale = 0.5,
                    coord = c("X", "Y"), file.name = NA)


int1=-1.5

# Biased intensity for observer bias - No distrubance
po3_X = data.frame(Intercept = 1, sp_env[,c(3:6)])
po3_beta = c(int1, 0.6, 2, 1, -0.8)
po3_intensity = exp(as.matrix(po3_X) %*% po3_beta)
PO3_rows = sample(1:sp1_sim$n, 180, prob = po3_intensity)
PO3 = sp1_sim[PO3_rows]

plot(PO3, pch=16, cex = 0.9, col="white")
points(PO3, pch=16, col=rgb(1, 0.5, 0, alpha=0.4))

```


## 1 - Patchiness of some covariates (environmental aspect) 
### A -  creating new variables

Then, we add human disturbance in different ways. First we consider that human disturbance can be seen through the covariates. landscape can have more patchiness. The NLMR package help to create different patchiness but in this exeample, for each year we have to rely another Gaussian random field process.
```{r, warning=FALSE}
# Creating distrubance for Year t+1
set.seed(2)
v1.Y2 <- nlm_fbm(ncol = 101, nrow = 101, fract_dim = 0.4, user_seed = 1)

v2 <- nlm_gaussianfield(ncol = 101, nrow = 101,
                        autocorr_range = 10,
                        mag_var = 80,
                        nug = 1, user_seed = 1)

V3.Y2 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 0.7)
v3.Y3 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 1.2)

v4.Y2 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 0.8)
v4.Y3 <- nlm_mpd(ncol = 101, nrow = 101, roughness = 1.1)

# Display the plot of the covariates
Lv1.2 = levelplot(v1.Y2, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE) 
Lv2 = levelplot(v2, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv3.2 = levelplot(V3.Y2, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv3.3 = levelplot(v3.Y3, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv4.2 = levelplot(v4.Y2, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
Lv4.3 = levelplot(v4.Y3, col.regions = rev(terrain.colors(255)),
                cuts=254, margin=FALSE, colorkey=FALSE) 
comb_levObj2 <- c(Lv1.2, Lv2, Lv3.2, Lv3.3, Lv4.2, Lv4.3,
                 layout = c(3, 2), merge.legends = T)
update(comb_levObj2, main="Environmental covariates Year 2 and 3")
```

#### B - Modifying variables 1

However, the variables created before do not show any obvious link from one year to the other. We can play directly on the covariates distribution by for exemple changing the intensity at some places in the window.

```{r, warning=FALSE}
# for variable v3 -++++++++++++++++++++++++++++++++++++
# Set so that long lines in R will be wrapped:

v3.df = as.data.frame(v3)
levelplot(v3.df$layer~ quad$X + quad$Y)

library(viridisLite)
LY1.test = levelplot(v3.df$layer~ quad$X + quad$Y, col.regions=inferno(20))

set.seed(6)

v3.df2 = v3.df
v3.df2$layer[v3.df2$layer > 0.6] = v3.df2$layer[v3.df2$layer > 0.6] +
  rnorm(length(length(v3.df2$layer[v3.df2$layer > 0.6])), 0, 2)

v3.df2.resc = (v3.df2$layer-min(v3.df2$layer))/
  (max(v3.df2$layer)-min(v3.df2$layer))
LY2.test = levelplot(v3.df2.resc~ quad$X + quad$Y, col.regions=inferno(20))

v3.df3 = v3.df2
v3.df3$layer[v3.df3$layer > 0.8] = v3.df3$layer[v3.df3$layer > 0.8] +
  rnorm(length(length(v3.df3$layer[v3.df3$layer > 0.8])), 0, 1)

v3.df3.resc = (v3.df3$layer-min(v3.df3$layer))/
  (max(v3.df3$layer)-min(v3.df3$layer))

LY3.test = levelplot(v3.df3.resc~ quad$X + quad$Y, col.regions=inferno(20))

update(c(LY1.test, LY2.test, LY3.test), layout = c(3, 1),
       main="Environmental covariates Year 1, 2 and 3")
```

### C - Modifying variables 2

Another possibility is to consider some centers of disturbance (points in space) that will influence the variable intensity depending on the distance to those centers.
```{r, warning=FALSE}
# For variable v4 -++++++++++++++++++++++++++++++
v4.df = as.data.frame(v4)
levelplot(v4.df$layer~ quad$X + quad$Y, col.regions=magma(20))
L4Y1.test = levelplot(v4.df$layer~ quad$X + quad$Y, col.regions=inferno(20))

xy <- matrix(c(25,30,87,80),nrow=2, byrow=T) 
p1 <- SpatialPoints(xy)

dfp = distanceFromPoints(v4, p1)
plot(dfp)
distfP = as.data.frame(dfp)

v4d = cbind(v4.df, distfP)
v4y2 = v4d 
colnames(v4y2) = c("raster", "dist")
v4y2$raster[v4y2$dist < 15] = v4y2$raster[v4y2$dist < 15]*0.6*max(v4y2$raster)
v4y2$raster[v4y2$dist > 15] = v4y2$raster[v4y2$dist > 15]*0.9*max(v4y2$raster)
v4y2$raster[v4y2$dist > 30] = v4y2$raster[v4y2$dist > 30]*1.2*max(v4y2$raster)
v4y2$raster[v4y2$dist > 60] = v4y2$raster[v4y2$dist > 60]*1.5*max(v4y2$raster)
v4y2.rsc = (v4y2$raster-min(v4y2$raster))/(max(v4y2$raster)-min(v4y2$raster))
L4Y2 = levelplot(v4y2.rsc~ quad$X + quad$Y, col.regions=inferno(20))

v4y3 = v4d 
colnames(v4y3) = c("raster", "dist")
v4y3$raster[v4y3$dist < 15] = v4y3$raster[v4y3$dist < 15]*0.1*max(v4y3$raster)
v4y3$raster[v4y3$dist > 15] = v4y3$raster[v4y3$dist > 15]*0.9*max(v4y3$raster)
v4y3$raster[v4y3$dist > 30] = v4y3$raster[v4y3$dist > 30]*1.7*max(v4y3$raster)
v4y3$raster[v4y3$dist > 60] = v4y3$raster[v4y3$dist > 60]*2.7*max(v4y3$raster)
v4y3.rsc = (v4y3$raster-min(v4y3$raster))/(max(v4y3$raster)-min(v4y3$raster))
L4Y3 = levelplot(v4y3$raster~ quad$X + quad$Y, col.regions=inferno(20))

update(c(L4Y1.test, L4Y2, L4Y3), layout = c(3, 1),
       main="Environmental covariates Year 1, 2 and 3")


### Other test for variable 4 
# we consider the centres created before that correspond to distrubance 
# and thus that change the intensity
v4.df = as.data.frame(v4)
levelplot(v4)
v4bis.Y2 = v4.df*v4y2$dist

v4bis.Y2.Lrsc = (v4bis.Y2$layer-min(v4bis.Y2$layer))/(max(v4bis.Y2$layer)-min(v4bis.Y2$layer))
L4bis.Y2.rsc = levelplot(v4bis.Y2.Lrsc~quad$X+quad$Y, col.regions=inferno(20))

v4bis.Y3 = v4bis.Y2*v4y2$dist*10
v4bis.Y3.Lrsc = (v4bis.Y3$layer-min(v4bis.Y3$layer))/(max(v4bis.Y3$layer)-min(v4bis.Y3$layer))
L4bis.Y3.rsc = levelplot(v4bis.Y3.Lrsc~quad$X+quad$Y, col.regions=inferno(20))

update(c(L4Y1.test, L4bis.Y2.rsc, L4bis.Y3.rsc), layout = c(3, 1),
       main="Environmental covariates Year 1, 2 and 3")


## test with multyple centers randomly created
set.seed(8)
c1 = runif(30, min=0, max=100)
c2 = runif(30, min=0, max=100)
xy2 <- matrix(cbind(c1, c2),ncol=2, byrow=F) 
p2 <- SpatialPoints(xy2)

dfp2 = distanceFromPoints(v4, p2)
plot(dfp2)
distfP2 = as.data.frame(dfp2)

v4.df = as.data.frame(v4)
levelplot(v4)
v4tre.Y2 = v4.df*distfP2$layer
v4tre.Y2.Lrsc = (v4tre.Y2$layer-min(v4tre.Y2$layer))/(max(v4tre.Y2$layer)-min(v4tre.Y2$layer))
L4tre.Y2.rsc = levelplot(v4tre.Y2.Lrsc~quad$X+quad$Y, col.regions=inferno(20))


v4tre.Y3 = v4tre.Y2*distfP2$layer*10
v4tre.Y3.Lrsc = (v4tre.Y3$layer-min(v4tre.Y3$layer))/(max(v4tre.Y3$layer)-min(v4tre.Y3$layer))
L4tre.Y3.rsc = levelplot(v4tre.Y3.Lrsc~quad$X+quad$Y, col.regions=inferno(20))

update(c(L4Y1.test, L4tre.Y2.rsc, L4tre.Y3.rsc), layout = c(3, 1),
       main="Environmental covariates Year 1, 2 and 3")



### All variables

Datav1.2 = as.data.frame(flip(v1.Y2,2))
Datav3.2 = as.data.frame(v3.df2.resc)
Datav3.3 = as.data.frame(v3.df3.resc)
Datav4.2 = as.data.frame(v4bis.Y2.Lrsc)                 
Datav4.3 = as.data.frame(v4bis.Y3.Lrsc) 

vmat.2 = as.matrix(data.frame(1, Datav1.2, Datav2, Datav3.2,
                              Datav3.3, Datav4.2, Datav4.3))
colnames(vmat.2)=c("int", "v1.2", "v2", "v3.2", "v3.3",
                   "v4.2", "v4.3")
vmat.df2= as.data.frame(vmat.2)
```

We consider for year 2 a certain patchiness coming from new covariates v1.2, v3.2 and v4.2.
```{r, warning=FALSE}
## Year 2

# environmental info at quad points and species locations
quads.2 = data.frame(X = quad$X, Y = quad$Y, V1 = vmat.df2$v1.2,
                     V2 = vmat.df$v2, V3=vmat.df2$v3.2,
                     V4=vmat.df2$v4.2)

sp_xy = data.frame(X = sp1_sim$x, Y = sp1_sim$y)

sp_env.2 = newenv.var(sp.xy = sp_xy, env.grid = quads.2, 
                    env.scale = 0.5, coord = c("X", "Y"),
                    file.name = NA)

int1=-1.5

# Biased intensity for observer bias - WITH distrubance
po3_X = data.frame(Intercept = 1, sp_env.2[,c(3:6)])
po3_beta = c(int1, -0.6, 2, 1, 0.8)
po3_intensity.2 = exp(as.matrix(po3_X) %*% po3_beta)
PO3_rows = sample(1:sp1_sim$n, 180, prob = po3_intensity.2)
PO3.Y2 = sp1_sim[PO3_rows]

plot(PO3.Y2, pch=16, cex = 0.9, col="white")
points(PO3.Y2, pch=16, col=rgb(1, 0.5, 0, alpha=0.4))
```

We do something similar for Year 3 where the patchiness is more important.
```{r, warning=FALSE}
### Year 3

# environmental info at quad points and species locations
quads.3 = data.frame(X = quad$X, Y = quad$Y, V1 = vmat.df2$v1.2,
                     V2 = vmat.df$v2, V3=vmat.df2$v3.3,
                     V4=vmat.df2$v4.3)

sp_xy = data.frame(X = sp1_sim$x, Y = sp1_sim$y)

sp_env.3 = newenv.var(sp.xy = sp_xy, env.grid = quads.3, 
                      env.scale = 0.5, coord = c("X", "Y"), file.name = NA)


int1=-1.5

# Biased intensity for observer bias - WITH distrubance
po3_X = data.frame(Intercept = 1, sp_env.3[,c(3:6)])
po3_beta = c(int1, -0.6, 2, 1, 0.8)
po3_intensity.3 = exp(as.matrix(po3_X) %*% po3_beta)
PO3_rows = sample(1:sp1_sim$n, 180, prob = po3_intensity.3)
PO3.Y3 = sp1_sim[PO3_rows]

plot(PO3.Y3, pch=16, cex = 0.9, col="white")
points(PO3.Y3, pch=16, col=rgb(1, 0.5, 0, alpha=0.4))


# plot of true intensity
LT=levelplot(sp1_int ~ quad$X + quad$Y, asp = "iso", col.regions=terrain.colors(20))

# PO data year 1
p3=xyplot(PO3$y~PO3$x, pch=16, col=rgb(1, 0.5, 0, alpha=0.4),
          xlab="", ylab="")

# PO data year 2
p3.y2=xyplot(PO3.Y2$y~PO3.Y2$x, pch=16, col=rgb(0.7, 0.5, 0, alpha=0.4),
             xlab="", ylab="")

# PO data year 3
p3.y3=xyplot(PO3.Y3$y~PO3.Y3$x, pch=16, col=rgb(0.5, 0.5, 0.2, alpha=0.4),
             xlab="", ylab="")

update(c(LT, p3, p3.y2, p3.y3, x.same = TRUE), layout = c(4, 1), 
       xlab = list(c("True intensity", "Year1", "Year2", "Year3"),
                   par.settings = list(layout.heights = list(panel = c(1, 1))))) 
```


## 2- Consider human disturbance with change in density of human pop
### A - Sample point pattern from the the true species intensity according to different environmental variables and the distance to the human disturbance.

We can consider that we have a covariate that represents the density of population in an area and that density evolves with time.
```{r, warning=FALSE}
# generate environmental covariate
XY = expand.grid(seq(0, 100, 1), seq(0, 100, 1))
X = XY[,1]
Y = XY[,2]

# Generate new covariates for population density
vd = (X + 300)^2 + (Y + 160)^2 - 5*X*Y

vd = -1*scale(vd)
Lvd = levelplot(vd ~ X + Y)

vd.Y2 = (X + 300)^2 + (Y + 90)^2 - 5*X*Y

vd.Y2 = -1*scale(vd.Y2)
Lvd.Y2 = levelplot(vd.Y2 ~ X + Y)

update(c(Lvd, Lvd.Y2, x.same = TRUE), layout = c(2, 1),
       xlab = list(c("Human disturbance Y1", "Year2"), 
                   par.settings = list(layout.heights = list(panel = c(1, 1))))) 


## Year 1
# environmental info at quad points and species locations
quads4 = data.frame(X = quad$X, Y = quad$Y, V1 = vmat.df$v1,
                    V2 = vmat.df$v2, V3= vmat.df$v3,
                    V4 = vmat.df$v4, Vd = vd)

sp_xy = data.frame(X = sp1_sim$x, Y = sp1_sim$y)

sp_env4 = newenv.var(sp.xy = sp_xy, env.grid = quads4, 
                    env.scale = 0.5, coord = c("X", "Y"), file.name = NA)


int1=-1.5

# Biased intensity for observer bias - No distrubance
po4_X = data.frame(Intercept = 1, sp_env4[,c(3:7)])
po4_beta = c(int1, -0.6, 2, 1, 0.8, -0.9)
po4_intensity = exp(as.matrix(po4_X) %*% po4_beta)
PO4_rows = sample(1:sp1_sim$n, 180, prob = po4_intensity)
PO4 = sp1_sim[PO4_rows]

plot(PO4, pch=16, cex = 0.9, col="white")
points(PO4, pch=16, col=rgb(1, 0.5, 0, alpha=0.4))


## Year 2
# environmental info at quad points and species locations
quads4.2 = data.frame(X = quad$X, Y = quad$Y, V1 = vmat.df$v1, V2 = vmat.df$v2,
                    V3= vmat.df$v3, V4 = vmat.df$v4, Vd = vd.Y2)

sp_xy = data.frame(X = sp1_sim$x, Y = sp1_sim$y)

sp_env4.2 = newenv.var(sp.xy = sp_xy, env.grid = quads4.2, 
                     env.scale = 0.5, coord = c("X", "Y"), file.name = NA)


int1=-1.5

# Biased intensity for observer bias - No distrubance
po4.2_X = data.frame(Intercept = 1, sp_env4.2[,c(3:7)])
po4.2_beta = c(int1, -0.6, 2, 1, 0.8, -0.9)
po4.2_intensity = exp(as.matrix(po4.2_X) %*% po4.2_beta)
PO4.2_rows = sample(1:sp1_sim$n, 180, prob = po4.2_intensity)
PO4.2 = sp1_sim[PO4.2_rows]

plot(PO4.2, pch=16, cex = 0.9, col="white")
points(PO4.2, pch=16, col=rgb(0.4, 0.5, 0.3, alpha=0.4))


p4.y1=xyplot(PO4$y~PO4$x, pch=16, col=rgb(0.7, 0.5, 0, alpha=0.4), 
             xlab="", ylab="")

p4.y2=xyplot(PO4.2$y~PO4.2$x, pch=16, col=rgb(0.4, 0.5, 0.3, alpha=0.4),
             xlab="", ylab="")


update(c(p4.y1, p4.y2, Lvd, Lvd.Y2, x.same = TRUE),
       layout = c(2, 2), 
       xlab = list(c(""), 
                   par.settings = list(layout.heights = list(panel = c(1, 1))))) 
```

### B - Move points according to human disturbance

Instead of creating point pattern from disturbed environment due to human intensity of presence we can also create movement for points due to their distance to the human disturbance center.

```{r, warning=F}
# Other possibility to simulate the movement
# we consider that the points from year 1 will move depending on the 
# human distance covariates and the distance to it

# calculate the center of the human disturbance
max(vd)

# Just to verify where is the center of the disturbance
vd.mat = as.data.frame(cbind(vd, quad$X, quad$Y))
colnames(vd.mat) = c("vd", "X", "Y")
vdmax.x = vd.mat$X[which.max(vd.mat$vd)]
vdmax.y = vd.mat$Y[which.max(vd.mat$vd)]

xy.d <- matrix(c(0,0),nrow=1, byrow=T) 

library(scales)

rast.y1 = raster(raster(ncol=101, nrow=101, xmn=0, ymn=0,
                        xmx=100, ymx=100))

values(rast.y1)=vd
PO3.xy = cbind(PO3$x, PO3$y)
pt3 <- SpatialPoints(PO3.xy)

# extract the distances to the distrubance for each point
pt3.rast = extract(flip(rast.y1,2), pt3)
summary(pt3.rast)

pt3.rast.rsc = (pt3.rast-min(pt3.rast, na.rm=T))/
  (max(pt3.rast, na.rm=T)-min(pt3.rast, na.rm=T))

PO3_y1 = PO3

PO3_y1$x = PO3$x + 9.4*pt3.rast.rsc 
PO3_y1$y = PO3$y + 9.4*pt3.rast.rsc

par(mfrow=c(1,2))
plot(flip(rast.y1,2))
points(PO3, col="turquoise", pch=16)

plot(flip(rast.y1,2))
points(PO3_y1, col="darkblue", pch=16)


# for year 2
# Just to verify where is the center of the disturbance
vdY2.mat = as.data.frame(cbind(vd.Y2, quad$X, quad$Y))
colnames(vdY2.mat) = c("vdY2", "X", "Y")
vdY2max.x = vdY2.mat$X[which.max(vdY2.mat$vdY2)]
vdY2max.y = vdY2.mat$Y[which.max(vdY2.mat$vdY2)]

xy.dY2 <- matrix(c(vdY2max.x, vdY2max.y),nrow=1, byrow=T) 

rast.y2 = raster(raster(ncol=101, nrow=101, xmn=0, ymn=0,
                        xmx=100, ymx=100))

values(rast.y2)=vd.Y2
PO3.xy = cbind(PO3$x, PO3$y)
pt3 <- SpatialPoints(PO3.xy)

# extract the distances to the distrubance for each point
pt3.rastY2 = extract(flip(rast.y2,2), pt3)
summary(pt3.rastY2)

pt3.rastY2.rsc = (pt3.rastY2-min(pt3.rastY2, na.rm=T))/
  (max(pt3.rastY2, na.rm=T)-min(pt3.rastY2, na.rm=T))

PO3_y2 = PO3

PO3_y2$x = PO3$x + 10.6*pt3.rastY2.rsc 
PO3_y2$y = PO3$y + 10.6*pt3.rastY2.rsc

par(mfrow=c(1,2))
plot(flip(rast.y2,2))
points(PO3, col="turquoise", pch=16)

plot(flip(rast.y2,2))
points(PO3_y2, col="blue2", pch=16)
```

Instead of moving all points we can also consider that only certain points will move and we can define how far they will move depends on their distance to human presence/disturbance.

```{r, warning=FALSE}
# Other possibility:
# we consider that not all points could move
# Those points are chosen by binomila process and considering the species intensity. Species will be more likely to move in lowest intensity area (less suitable places..)

levelplot(sp1_int ~ quad$X + quad$Y, asp = "iso", main = "True intensity")

# get the probability of moving from the species intensity
pt.val1 = sp1_int_im[PO3]
# 1/pt intensity to consider pts in less suitable area
pt.val1.rsc = (1/pt.val1-min(1/pt.val1, na.rm=T))/
  (max(1/pt.val1, na.rm=T)-min(1/pt.val1, na.rm=T))

# Chosing the points to move
Binom1 = rbinom(PO3$n, size=1, prob = pt.val1.rsc)
pres1 = (Binom1 == 1)
PO3.pres1 = PO3[pres1,]

plot(sp1_int_im)
points(PO3.pres1, col="yellow")

# Move those points according to the distance to the disturbance
PO3_y1b = PO3.pres1

PO3_y1b.xy = cbind(PO3_y1b$x, PO3_y1b$y)
pt3B <- SpatialPoints(PO3_y1b.xy)

# extract the distances to the distrubance for each point
pt3B.rastY2 = extract(flip(rast.y2,2), pt3B)
summary(pt3B.rastY2)

pt3B.rastY2.rsc = (pt3B.rastY2-min(pt3B.rastY2, na.rm=T))/
  (max(pt3B.rastY2, na.rm=T)-min(pt3B.rastY2, na.rm=T))

PO3_y1b$x = PO3.pres1$x + 15.4*pt3B.rastY2.rsc 
PO3_y1b$y = PO3.pres1$y + 15.4*pt3B.rastY2.rsc

par(mfrow=c(1,2))
plot(flip(rast.y1,2))
points(PO3, col="turquoise", pch=16)

plot(flip(rast.y1,2))
abs1= (Binom1==0)
points(PO3[abs1,], col="turquoise", pch=16)
points(PO3_y1b, col="darkblue", pch=16)

```


# Occupancy Data

## 1- Patchiness in the covariates
This work can also be done on Occupancy data. We first consider the patchiness from the environmental covariates.
```{r, warning=FALSE}
# Disturbance results as more patchiness in the covariates
# Year 1
sp1_coef = c(-0.01, -0.6, 2, 1, 0.8)
sp1_int = exp(env.mat %*% sp1_coef)

sp1_int_im = as.im(data.frame(x = quad$X, y = quad$Y, z = sp1_int))
sp1occ_sim = rpoispp(sp1_int_im)
sp1occ_sim

# *Generate occupancy data from species true intensity*
# Creating the grid sites
XY.occ = expand.grid(seq(0, 100, 10), seq(0, 100, 10)) 
X.occ = XY.occ[,1]
Y.occ = XY.occ[,2]

sp_and_occ = ppp(x = c(X.occ, sp1occ_sim$x), y = c(Y.occ, sp1occ_sim$y),
                 marks = c(rep("Occ", length(X.occ)), 
                           rep("Sp", sp1occ_sim$n)),
                 window = win)
dist_sp_occ = nndist(sp_and_occ, k = 1, by = as.factor(marks(sp_and_occ)))

# compute distance to nearest species
sp_occ_dists = dist_sp_occ[1:length(X.occ), 2]

# species considered present at site if nearest one is within 0.25 units
occ_present = as.numeric(sp_occ_dists <= 0.25)
table(occ_present) 
occ_present2 = occ_present

occ_paste = paste(X.occ, Y.occ)
quad_paste = paste(quad$X, quad$Y)
occ_quadrow = match(occ_paste, quad_paste)

# Proba of detection
set.seed(13)
v7 = nlm_randomcluster(ncol = 101, nrow = 101, p = 0.6,
                       ai = c(0.25, 0.25, 0.5))
Datav7=as.data.frame(v7)
v8 = rep(0, length(v7)) # categorical for PO bias

v8[Datav7 < quantile(v7, 0.25)] = 1
levelplot(v8 ~ quad[,1] + quad[,2], main = "v8", asp = "iso")

p_detect_cov = clogloginv(v8[occ_quadrow])*occ_present2  

n_visits = 5
sim_history = matrix(as.integer(matrix(rep(p_detect_cov, times = n_visits),
                                       length(X.occ), n_visits)>                                  matrix(runif(length(X.occ)*n_visits), 
                                                                                                         length(X.occ),
                                                                                                         n_visits)), length(X.occ), n_visits)

# Plot of 4 out the 5 visits froom the history
library(RColorBrewer)
col.l <- colorRampPalette(c("white","midnightblue"),
                          space = "rgb")
ckey <- list(labels=list(cex=1.2))
L1=levelplot(sim_history[,1]~X.occ + Y.occ, main="visit1",
             col.regions = col.l, colorkey=FALSE)
L2=levelplot(sim_history[,2]~X.occ + Y.occ, main="visit2",
             col.regions = col.l, colorkey=FALSE)
L3=levelplot(sim_history[,3]~X.occ + Y.occ, main="visit3",
             col.regions = col.l, colorkey=FALSE)
L4=levelplot(sim_history[,4]~X.occ + Y.occ, main="visit4",
             col.regions = col.l, colorkey=ckey)
comb_levObj <- c(L4, L3, L2, L1,
                 layout = c(2, 2), merge.legends = T)
update(comb_levObj,
       main="occupancy history - 4 visits")

# Occupancy plot
site_sum = apply(sim_history, 1, sum)
plot_xy =expand.grid(seq(0, 100, 5), seq(0, 100, 5))
plot_x = plot_xy[,1]
plot_y = plot_xy[,2]
plot_id = paste(plot_x, plot_y)
occ_id = paste(X.occ, Y.occ)
occ_match = match(occ_id, plot_id)
plot_z = rep(NA, length(plot_x))
plot_z[occ_match] = site_sum
Locc.Y1 = levelplot(plot_z ~ plot_x + plot_y, asp = "iso", cuts = 5,
                    col.regions = rainbow(6, start = 0.03, end = 0.17)[6:1])
```

We repeat the same scheme for Year 2 and 3.
```{r, warning=FALSE}
# Year 2
sp1_coef = c(-0.01, -0.6, 2, 1, 0.8)
env.mat2 = vmat.2[,c(1:4,6)]
sp1_int = exp(env.mat2 %*% sp1_coef)

sp1_int_im = as.im(data.frame(x = quad$X, y = quad$Y,
                              z = sp1_int))
sp1occ_sim = rpoispp(sp1_int_im)
sp1occ_sim

# *Generate occupancy data from species true intensity*
# Creating the grid sites
XY.occ = expand.grid(seq(0, 100, 10), seq(0, 100, 10)) 
X.occ = XY.occ[,1]
Y.occ = XY.occ[,2]

sp_and_occ = ppp(x = c(X.occ, sp1occ_sim$x), 
                 y = c(Y.occ, sp1occ_sim$y),
                 marks = c(rep("Occ", length(X.occ)), 
                           rep("Sp", sp1occ_sim$n)), window = win)

dist_sp_occ = nndist(sp_and_occ, k = 1,
                     by = as.factor(marks(sp_and_occ)))

# compute distance to nearest species
sp_occ_dists = dist_sp_occ[1:length(X.occ), 2]

# species considered present at site if nearest one is within 0.25 units
occ_present = as.numeric(sp_occ_dists <= 0.25)
table(occ_present) 
occ_present2 = occ_present

# New probaility of detection
occ_paste = paste(X.occ, Y.occ)
quad_paste = paste(quad$X, quad$Y)
occ_quadrow = match(occ_paste, quad_paste)

p_detect_cov = clogloginv(v8[occ_quadrow])*occ_present2  

n_visits = 5
sim_history = matrix(as.integer(matrix(rep(p_detect_cov, times = n_visits),
                                       length(X.occ), 
                                       n_visits) >  
                                  matrix(runif(length(X.occ)*n_visits),
                                         length(X.occ), n_visits)),
                     length(X.occ), n_visits)

# Plot of 4 out the 5 visits froom the history
library(RColorBrewer)
col.l <- colorRampPalette(c("white","midnightblue"), 
                          space = "rgb")
ckey <- list(labels=list(cex=1.2))
L1=levelplot(sim_history[,1]~X.occ + Y.occ, main="visit1",
             col.regions = col.l, colorkey=FALSE)
L2=levelplot(sim_history[,2]~X.occ + Y.occ, main="visit2",
             col.regions = col.l, colorkey=FALSE)
L3=levelplot(sim_history[,3]~X.occ + Y.occ, main="visit3",
             col.regions = col.l, colorkey=FALSE)
L4=levelplot(sim_history[,4]~X.occ + Y.occ, main="visit4",
             col.regions = col.l, colorkey=ckey)
comb_levObj <- c(L4, L3, L2, L1,
                 layout = c(2, 2), merge.legends = T)
update(comb_levObj,
       main="occupancy history - 4 visits")

# Occupancy plot
site_sum = apply(sim_history, 1, sum)
plot_xy =expand.grid(seq(0, 100, 5), seq(0, 100, 5))
plot_x = plot_xy[,1]
plot_y = plot_xy[,2]
plot_id = paste(plot_x, plot_y)
occ_id = paste(X.occ, Y.occ)
occ_match = match(occ_id, plot_id)
plot_z = rep(NA, length(plot_x))
plot_z[occ_match] = site_sum
Locc.Y2 = levelplot(plot_z ~ plot_x + plot_y, asp = "iso", cuts = 5,
                    col.regions = rainbow(6, start = 0.03, end = 0.17)[6:1])


# Year 3
sp1_coef = c(-0.01, -0.6, 2, 1, 0.8)
env.mat3 = vmat.2[,c(1:3, 5, 7)]
sp1_int = exp(env.mat3 %*% sp1_coef)

sp1_int_im = as.im(data.frame(x = quad$X, y = quad$Y, z = sp1_int))
sp1occ_sim = rpoispp(sp1_int_im)
sp1occ_sim

# *Generate occupancy data from species true intensity*
# Creating the grid sites
XY.occ = expand.grid(seq(0, 100, 10), seq(0, 100, 10)) 
X.occ = XY.occ[,1]
Y.occ = XY.occ[,2]

sp_and_occ = ppp(x = c(X.occ, sp1occ_sim$x), y = c(Y.occ, sp1occ_sim$y),
                 marks = c(rep("Occ", length(X.occ)), 
                           rep("Sp", sp1occ_sim$n)),
                 window = win)
dist_sp_occ = nndist(sp_and_occ, k = 1, by = as.factor(marks(sp_and_occ)))

# compute distance to nearest species
sp_occ_dists = dist_sp_occ[1:length(X.occ), 2]

# species considered present at site if nearest one is within 0.25 units
occ_present = as.numeric(sp_occ_dists <= 0.25) 
table(occ_present) 
occ_present2 = occ_present

occ_paste = paste(X.occ, Y.occ)
quad_paste = paste(quad$X, quad$Y)
occ_quadrow = match(occ_paste, quad_paste)

p_detect_cov = clogloginv(v8[occ_quadrow])*occ_present2  

n_visits = 5
sim_history = matrix(as.integer(matrix(rep(p_detect_cov, 
                                           times = n_visits),
                                       length(X.occ), n_visits) >
                                  matrix(runif(length(X.occ)*n_visits),
                                         length(X.occ), n_visits)),
                                          length(X.occ), n_visits)

# Plot of 4 out the 5 visits froom the history
library(RColorBrewer)
col.l <- colorRampPalette(c("white","midnightblue"), 
                          space = "rgb")
ckey <- list(labels=list(cex=1.2))
L1=levelplot(sim_history[,1]~X.occ + Y.occ, main="visit1",
             col.regions = col.l, colorkey=FALSE)
L2=levelplot(sim_history[,2]~X.occ + Y.occ, main="visit2",
             col.regions = col.l, colorkey=FALSE)
L3=levelplot(sim_history[,3]~X.occ + Y.occ, main="visit3",
             col.regions = col.l, colorkey=FALSE)
L4=levelplot(sim_history[,4]~X.occ + Y.occ, main="visit4",
             col.regions = col.l, colorkey=ckey)
comb_levObj <- c(L4, L3, L2, L1,
                 layout = c(2, 2), merge.legends = T)
update(comb_levObj,
       main="occupancy history - 4 visits")

# Occupancy plot
site_sum = apply(sim_history, 1, sum)
plot_xy =expand.grid(seq(0, 100, 5), seq(0, 100, 5))
plot_x = plot_xy[,1]
plot_y = plot_xy[,2]
plot_id = paste(plot_x, plot_y)
occ_id = paste(X.occ, Y.occ)
occ_match = match(occ_id, plot_id)
plot_z = rep(NA, length(plot_x))
plot_z[occ_match] = site_sum
Locc.Y3 = levelplot(plot_z ~ plot_x + plot_y, asp = "iso", 
                    cuts = 5, col.regions = rainbow(6, start = 0.03, end = 0.17)[6:1])

update(c(Locc.Y1, Locc.Y2, Locc.Y3, x.same = TRUE), layout = c(3, 1),
       main="Occupancy data for different covariates patchiness", 
       xlab = list(c("Year 1", "Year 2", "Year 3"), 
                   par.settings = list(layout.heights = list(panel = c(1, 1)))))
```


## 2- density of population
We can consider for occupancy data that the detection dependent on the density of people in the area. 
```{r, warning=FALSE}
# Disturbance in terms of detection only and density of people: 
#More people less possibility of detecting~

sp1_coef = c(-0.01, -0.6, 2, 1, 0.8)
sp1_int = exp(env.mat %*% sp1_coef)

sp1_int_im = as.im(data.frame(x = quad$X, y = quad$Y, z = sp1_int))
sp1occ_sim = rpoispp(sp1_int_im)
sp1occ_sim

# *Generate occupancy data from species true intensity*
# Creating the grid sites
XY.occ = expand.grid(seq(0, 100, 10), seq(0, 100, 10)) 
X.occ = XY.occ[,1]
Y.occ = XY.occ[,2]

sp_and_occ = ppp(x = c(X.occ, sp1occ_sim$x), y = c(Y.occ, sp1occ_sim$y),
                 marks = c(rep("Occ", length(X.occ)), rep("Sp", sp1occ_sim$n)),
                 window = win)
dist_sp_occ = nndist(sp_and_occ, k = 1, by = as.factor(marks(sp_and_occ)))

# compute distance to nearest species
sp_occ_dists = dist_sp_occ[1:length(X.occ), 2]

# species considered present at site if nearest one is within 0.25 units
occ_present = as.numeric(sp_occ_dists <= 0.25)
table(occ_present) 
occ_present2 = occ_present

# New probaility of detection
occ_paste = paste(X.occ, Y.occ)
quad_paste = paste(quad$X, quad$Y)
occ_quadrow = match(occ_paste, quad_paste)


# Year 1
# vd is the density of people
p_detect_cov = clogloginv(-vd[occ_quadrow])*occ_present2  

n_visits = 5
sim_history = matrix(as.integer(matrix(rep(p_detect_cov, times = n_visits),
                                       length(X.occ), n_visits) >
                                  matrix(runif(length(X.occ)*n_visits),
                                         length(X.occ), n_visits)),
                     length(X.occ), n_visits)

# Plot of 4 out the 5 visits froom the history
library(RColorBrewer)
col.l <- colorRampPalette(c("white","midnightblue"), space = "rgb")
ckey <- list(labels=list(cex=1.2))
L1=levelplot(sim_history[,1]~X.occ + Y.occ, main="visit1",
             col.regions = col.l, colorkey=FALSE)
L2=levelplot(sim_history[,2]~X.occ + Y.occ, main="visit2",
             col.regions = col.l, colorkey=FALSE)
L3=levelplot(sim_history[,3]~X.occ + Y.occ, main="visit3",
             col.regions = col.l, colorkey=FALSE)
L4=levelplot(sim_history[,4]~X.occ + Y.occ, main="visit4",
             col.regions = col.l, colorkey=ckey)
comb_levObj <- c(L4, L3, L2, L1,
                 layout = c(2, 2), merge.legends = T)
update(comb_levObj,
       main="occupancy history - 4 visits")

# Occupancy plot
site_sum = apply(sim_history, 1, sum)
plot_xy =expand.grid(seq(0, 100, 5), seq(0, 100, 5))
plot_x = plot_xy[,1]
plot_y = plot_xy[,2]
plot_id = paste(plot_x, plot_y)
occ_id = paste(X.occ, Y.occ)
occ_match = match(occ_id, plot_id)
plot_z = rep(NA, length(plot_x))
plot_z[occ_match] = site_sum
Locc.Y1 = levelplot(plot_z ~ plot_x + plot_y, asp = "iso", cuts = 5,
          col.regions = rainbow(6, start = 0.03, end = 0.17)[6:1])

# Year 2
p_detect_cov2 = clogloginv(-vd.Y2[occ_quadrow])*occ_present2  

n_visits = 5
sim_history2 = matrix(as.integer(matrix(rep(p_detect_cov2, 
                                            times = n_visits),
                                       length(X.occ), n_visits) >
                                  matrix(runif(length(X.occ)*n_visits),
                                         length(X.occ), n_visits)),
                     length(X.occ), n_visits)

# Plot of 4 out the 5 visits froom the history
library(RColorBrewer)
col.l <- colorRampPalette(c("white","midnightblue"), space = "rgb")
ckey <- list(labels=list(cex=1.2))
L1=levelplot(sim_history2[,1]~X.occ + Y.occ, main="visit1",
             col.regions = col.l, colorkey=FALSE)
L2=levelplot(sim_history2[,2]~X.occ + Y.occ, main="visit2",
             col.regions = col.l, colorkey=FALSE)
L3=levelplot(sim_history2[,3]~X.occ + Y.occ, main="visit3",
             col.regions = col.l, colorkey=FALSE)
L4=levelplot(sim_history2[,4]~X.occ + Y.occ, main="visit4",
             col.regions = col.l, colorkey=ckey)
comb_levObj <- c(L4, L3, L2, L1,
                 layout = c(2, 2), merge.legends = T)
update(comb_levObj,
       main="occupancy history Year 2- 4 visits")

# Occupancy plot
site_sum2 = apply(sim_history2, 1, sum)
plot_xy =expand.grid(seq(0, 100, 5), seq(0, 100, 5))
plot_x = plot_xy[,1]
plot_y = plot_xy[,2]
plot_id = paste(plot_x, plot_y)
occ_id = paste(X.occ, Y.occ)
occ_match = match(occ_id, plot_id)
plot_z = rep(NA, length(plot_x))
plot_z[occ_match] = site_sum2
Locc.Y2 = levelplot(plot_z ~ plot_x + plot_y, asp = "iso", cuts = 5,
          col.regions = rainbow(6, start = 0.03, end = 0.17)[6:1])

update(c(Lvd, Lvd.Y2, Locc.Y1, Locc.Y2, x.same = TRUE), 
       main="Occupancy data with different density of population", 
       layout = c(2, 2), 
       xlab = list(c("Year 1", "Year 2"),
                   par.settings = list(layout.heights = list(panel = c(1, 1))))) 

```
